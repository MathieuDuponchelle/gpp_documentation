<h2 id="gpp.worker" c_name="GPPWorker" python_name="GPP.Worker">GPP.Worker</h2>

<p class="graphviz">
<!-- Generated by graphviz version 2.38.0 (20140413.2041) --><!-- Title: %3 Pages: 1 --><svg width="110pt" height="116pt" viewBox="0.00 0.00 110.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)"><title>%3</title><polygon fill="white" stroke="none" points="-4,4 -4,-112 106,-112 106,4 -4,4"/><!-- GObject.Object --><g id="node1" class="node"><title>GObject.Object</title><g id="a_node1"><a xlink:href="https://developer.gnome.org/gobject/unstable//gobject-The-Base-Object-Type.html#GObject" xlink:title="GObject.Object"><path fill="none" stroke="black" d="M90,-108C90,-108 12,-108 12,-108 6,-108 0,-102 0,-96 0,-96 0,-84 0,-84 0,-78 6,-72 12,-72 12,-72 90,-72 90,-72 96,-72 102,-78 102,-84 102,-84 102,-96 102,-96 102,-102 96,-108 90,-108"/><text text-anchor="middle" x="51" y="-86.3" font-family="Times,serif" font-size="14.00">GObject.Object</text></a></g></g><!-- GPP.Worker --><g id="node2" class="node"><title>GPP.Worker</title><g id="a_node2"><a xlink:href="#gpp.worker" xlink:title="GPP.Worker"><path fill="none" stroke="black" d="M82.5,-36C82.5,-36 19.5,-36 19.5,-36 13.5,-36 7.5,-30 7.5,-24 7.5,-24 7.5,-12 7.5,-12 7.5,-6 13.5,-0 19.5,-0 19.5,-0 82.5,-0 82.5,-0 88.5,-0 94.5,-6 94.5,-12 94.5,-12 94.5,-24 94.5,-24 94.5,-30 88.5,-36 82.5,-36"/><text text-anchor="middle" x="51" y="-14.3" font-family="Times,serif" font-size="14.00">GPP.Worker</text></a></g></g><!-- GObject.Object&#45;&gt;GPP.Worker --><g id="edge1" class="edge"><title>GObject.Object&#45;&gt;GPP.Worker</title><path fill="none" stroke="black" d="M51,-71.6966C51,-63.9827 51,-54.7125 51,-46.1124"/><polygon fill="black" stroke="black" points="54.5001,-46.1043 51,-36.1043 47.5001,-46.1044 54.5001,-46.1043"/></g></g></svg></p>

  [GPP.Worker](#gpp.worker) receives requests from a [GPP.Queue](#gpp.queue), transmits them
as a simple string to the user, and notifies the queue when the
user marks the task as done.

> Set up and start a simple worker, which will take a lot of time to multiply the request by 2, and sometimes inexplicably fail.

```c
#include <glib-unix.h>

#include "gpp.h"

#define FAILURE_ODDS 4

#define GPP_TYPE_MULTIPLYING_WORKER (gpp_multiplying_worker_get_type ())

G_DECLARE_FINAL_TYPE (GPPMultiplyingWorker, gpp_multiplying_worker, GPP,
    MULTIPLYING_WORKER, GPPWorker);

struct _GPPMultiplyingWorker
{
  GPPWorker parent;
  GRand *rand_source;
  gchar *reply;
};

G_DEFINE_TYPE (GPPMultiplyingWorker, gpp_multiplying_worker, GPP_TYPE_WORKER);

static gboolean
set_task_done (GPPMultiplyingWorker * self)
{
  g_print ("one task done\n");
  if (g_rand_int (self->rand_source) % FAILURE_ODDS == 0) {
    g_print ("Actually it didn't work sorry\n");
    gpp_worker_set_task_done (GPP_WORKER (self), NULL, FALSE);
  } else {
    g_print ("no problem !!\n");
    gpp_worker_set_task_done (GPP_WORKER (self), self->reply, TRUE);
  }
  return FALSE;
}

static gboolean
handle_request (GPPWorker * worker, const gchar * request)
{
  GPPMultiplyingWorker *self = GPP_MULTIPLYING_WORKER (worker);
  g_print ("doing one task, request is %s\n", request);

  if (g_rand_int (self->rand_source) % FAILURE_ODDS == 0) {
    g_print ("I can't even start\n");
    return FALSE;
  }

  self->reply = g_strdup_printf ("Result : %d", atoi (request) * 2);
  g_timeout_add (1000, (GSourceFunc) set_task_done, self);
  return TRUE;
}

static void
gpp_multiplying_worker_class_init (GPPMultiplyingWorkerClass * klass)
{
  GPPWorkerClass *gpp_worker_class = GPP_WORKER_CLASS (klass);

  gpp_worker_class->handle_request = handle_request;
}

static void
gpp_multiplying_worker_init (GPPMultiplyingWorker * self)
{
  self->rand_source = g_rand_new ();
}

static gboolean
interrupted_cb (GMainLoop * loop)
{
  g_main_loop_quit (loop);
  return FALSE;
}

int
main (void)
{
  GMainLoop *loop = g_main_loop_new (NULL, FALSE);
  GPPMultiplyingWorker *worker =
      g_object_new (GPP_TYPE_MULTIPLYING_WORKER, NULL);

  g_unix_signal_add_full (G_PRIORITY_HIGH, SIGINT, (GSourceFunc) interrupted_cb,
      loop, NULL);
  gpp_worker_start (GPP_WORKER (worker));

  g_main_loop_run (loop);
  g_object_unref (worker);
  return 0;
}

```

  <h3 id='JyvCnJ' class='subsection'><u>Methods:</u></h3>

<div class='prototype_start'></div>

<h3 id="gpp.worker.new" c_name="gpp_worker_new">GPP.Worker.new</h3>

```c
GPPWorker* gpp_worker_new (void);

```

*Returns*: the newly-created [GPP.Worker](#gpp.worker).

<div class='prototype_end'></div>

Create a new [GPP.Worker](#gpp.worker), which doesn't yet listen to request from
the [GPP.Queue](#gpp.queue).
Start it with [GPP.Worker.start](#gpp.worker.start)

<div class='prototype_start'></div>

<h3 id="gpp.worker.start" c_name="gpp_worker_start" python_name="GPP.Worker.start">GPP.Worker.start</h3>

```c
gboolean gpp_worker_start (GPPWorker* self);

```

```python
@accepts(GPP.Worker)
@returns(bool)
def start(self):
    # Python wrapper for gpp_worker_start()

```
*self*: A [GPP.Worker](#gpp.worker) that will start handling requests.

*Returns*: **TRUE** if **self** could be started, **FALSE** if it was already.

<div class='prototype_end'></div>

This will make **self** start handling requests.

<div class='prototype_start'></div>

<h3 id="gpp.worker.set_task_done" c_name="gpp_worker_set_task_done" python_name="GPP.Worker.set_task_done">GPP.Worker.set_task_done</h3>

```c
gboolean gpp_worker_set_task_done (GPPWorker* self,
                                   const gchar* reply,
                                   gboolean success);

```

```python
@accepts(GPP.Worker, unicode, bool)
@returns(bool)
def set_task_done(self, reply, success):
    # Python wrapper for gpp_worker_set_task_done()

```
*self*: A [GPP.Worker](#gpp.worker).

*reply*: A string that will be passed to the client.

*success*: Whether the task was successfully handled.

*Returns*: **TRUE** if the task was marked as done, **FALSE** otherwise.

<div class='prototype_end'></div>

Call this function when your worker has finished handling a task.

<h3 id='uDUkkI' class='subsection'><u>Virtual Methods:</u></h3>

<div class='prototype_start'></div>

<h3 id="gpp.worker.do_handle_request" c_name="GPPWorkerClass:handle_request" python_name="GPP.Worker.do_handle_request">GPP.Worker.do_handle_request</h3>

```c
gboolean GPPWorkerClass->handle_request (GPPWorker* self,
                               const gchar* request);

```

```python
@accepts(GPP.Worker, unicode)
@returns(bool)
def do_handle_request(self, request):

```
*self*: the [GPP.Worker](#gpp.worker)

*request*: The request to handle

*Returns*: **TRUE** if the worker can handle that request, **FALSE** otherwise.

<div class='prototype_end'></div>

Implement this method to handle requests, requests *MUST* be
handled asynchronously as this method should not block, call
[GPP.Worker.set_task_done](#gpp.worker.set_task_done) when the request has been handled.

