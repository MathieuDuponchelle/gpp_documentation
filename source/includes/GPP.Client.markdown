<h2 id="gpp.client" c_name="GPPClient" python_name="GPP.Client">GPP.Client</h2>

<p class="graphviz">
<!-- Generated by graphviz version 2.38.0 (20140413.2041) --><!-- Title: %3 Pages: 1 --><svg width="110pt" height="116pt" viewBox="0.00 0.00 110.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)"><title>%3</title><polygon fill="white" stroke="none" points="-4,4 -4,-112 106,-112 106,4 -4,4"/><!-- GObject.Object --><g id="node1" class="node"><title>GObject.Object</title><g id="a_node1"><a xlink:href="https://developer.gnome.org/gobject/unstable//gobject-The-Base-Object-Type.html#GObject" xlink:title="GObject.Object"><path fill="none" stroke="black" d="M90,-108C90,-108 12,-108 12,-108 6,-108 0,-102 0,-96 0,-96 0,-84 0,-84 0,-78 6,-72 12,-72 12,-72 90,-72 90,-72 96,-72 102,-78 102,-84 102,-84 102,-96 102,-96 102,-102 96,-108 90,-108"/><text text-anchor="middle" x="51" y="-86.3" font-family="Times,serif" font-size="14.00">GObject.Object</text></a></g></g><!-- GPP.Client --><g id="node2" class="node"><title>GPP.Client</title><g id="a_node2"><a xlink:href="#gpp.client" xlink:title="GPP.Client"><path fill="none" stroke="black" d="M78,-36C78,-36 24,-36 24,-36 18,-36 12,-30 12,-24 12,-24 12,-12 12,-12 12,-6 18,-0 24,-0 24,-0 78,-0 78,-0 84,-0 90,-6 90,-12 90,-12 90,-24 90,-24 90,-30 84,-36 78,-36"/><text text-anchor="middle" x="51" y="-14.3" font-family="Times,serif" font-size="14.00">GPP.Client</text></a></g></g><!-- GObject.Object&#45;&gt;GPP.Client --><g id="edge1" class="edge"><title>GObject.Object&#45;&gt;GPP.Client</title><path fill="none" stroke="black" d="M51,-71.6966C51,-63.9827 51,-54.7125 51,-46.1124"/><polygon fill="black" stroke="black" points="54.5001,-46.1043 51,-36.1043 47.5001,-46.1044 54.5001,-46.1043"/></g></g></svg></p>

  [GPP.Client](#gpp.client) sends requests to a [GPP.Queue](#gpp.queue), and emits a signal
with the possible reply and the status of the task once it has been executed.

A per-request retry limit can be set when calling [GPP.Client.send_request](#gpp.client.send_request)

> Set up and start a simple client, which will send requests for numbers to be multiplied, and will not take 'No' for an answer.

```c
#include <glib-unix.h>
#include "gpp.h"

static gchar *
make_new_task (void)
{
  static int sequence = 0;
  gchar *task = g_strdup_printf ("%d", sequence);
  sequence++;

  g_print ("Doing task %s\n", task);
  return task;
}

static void
task_done_cb (GPPClient *client, gboolean success, const gchar *reply, gpointer unused)
{
  if (!success)
    g_print ("task failed\n");
  else
    g_print ("task succeeded : %s\n", reply);
  gpp_client_send_request (client, make_new_task (), -1);
}

static gboolean
interrupted_cb (GMainLoop *loop)
{
  g_main_loop_quit (loop);
  return FALSE;
}

int main (void)
{
  GMainLoop *loop = g_main_loop_new (NULL, FALSE);
  GPPClient *client = gpp_client_new ();

  g_unix_signal_add_full (G_PRIORITY_HIGH, SIGINT, (GSourceFunc) interrupted_cb, loop, NULL);
  g_signal_connect (client, "request-handled", G_CALLBACK (task_done_cb), NULL);
  gpp_client_send_request (client, make_new_task(), -1);
  g_main_loop_run (loop);
  g_object_unref (client);
  return 0;
}

```

  <h3 id='AdHVkn' class='subsection'><u>Methods:</u></h3>

<div class='prototype_start'></div>

<h3 id="gpp.client.new" c_name="gpp_client_new">GPP.Client.new</h3>

```c
GPPClient* gpp_client_new (void);

```

*Returns*: the newly-created [GPP.Client](#gpp.client).

<div class='prototype_end'></div>

Create a new [GPP.Client](#gpp.client).
Use it to send requests with [GPP.Client.send_request](#gpp.client.send_request)

<div class='prototype_start'></div>

<h3 id="gpp.client.send_request" c_name="gpp_client_send_request" python_name="GPP.Client.send_request">GPP.Client.send_request</h3>

```c
gboolean gpp_client_send_request (GPPClient* self,
                                  const gchar* request,
                                  gint retries);

```

```python
@accepts(GPP.Client, unicode, int)
@returns(bool)
def send_request(self, request, retries):
    # Python wrapper for gpp_client_send_request()

```
*self*: A [GPP.Client](#gpp.client) that will send the request.

*request*: A simple string that will be passed to the [GPP.Worker](#gpp.worker).

*retries*: The number of times to retry before signaling that
the request was handled, -1 means retry forever.

*Returns*: **TRUE** if **request** was made, **FALSE** if one is already being made.

<div class='prototype_end'></div>

This will make **self** send **request** to a [GPP.Queue](#gpp.queue).

<h3 id='aClCSP' class='subsection'><u>Signals:</u></h3>

<div class='prototype_start'></div>

<h3 id="gpp.client-request-handled" c_name="gpp_client-request-handled" python_name="GPP.Client-request-handled">GPP.Client-request-handled</h3>

```c
void request-handled (gboolean success,
                      gchar* reply);

```

```python
def callback(client, success, reply, user_param1, ...)

```
*success*: Whether the request was successfully executed

*reply*: The reply provided by the [GPP.Worker](#gpp.worker) , as a simple string

<div class='prototype_end'></div>

Connect to this signal to be notified when the current request
has been handled.

